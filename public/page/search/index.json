[{"content":"Rust的 Clap Crate 非常适用于开发命令行程序，它是一个“简单易用、高效且功能齐全的命令行参数解析器”。\nClap的作用在于帮助我们定义命令行工具的各种指令和用法，并解析用户使用的什么指令。之后我们只需要编写对应指令的功能代码即可。\n在这里简单记录一下它的一些用法。\ncrates.io: link docs.rs: link repo: link Exapmles: link 本文编写时：\n1 clap = \u0026#34;4.5.29\u0026#34; Clap的两种API Clap目前可以使用这两种方式构建命令行程序：\nBuilder API Derive API 官方的example多数都提供了两种方式的示例。 若要使用Derive API，记得要添加feature：\n1 clap = { version = \u0026#34;4.5.28\u0026#34;, features = [\u0026#34;derive\u0026#34;] } 两种构建方式的区别主要是：\nBuilder API\n链式调用的方式构建程序。 由于是 链式调用，代码 很长很复杂，可复用度较低。但在命令行参数需要经常变动调整时比较方便，加减几个函数调用就行。 Derive API\n声明式，通过定义命令和参数对应的 Strut 和 Enum 并在上面使用 属性宏 构建程序。 使用 声明式 构建，代码 直观简洁，方便理解和维护。适合参数和命令比较稳定的命令行程序。 使用 Derive API 可以兼顾开发效率和可维护性，同时上手方便。如果有复杂定制或控制更多细节的需求，再使用Builder API。 在特定情况下，Derive 和 Builder API 可以混合使用： Mixing Builder and Derive APIs\n使用方式 官方给的Git示例比较好，推荐查看：\ngit-Builder API git-Derive API Builder API Builder API 下，我们需要创建一个Command，通过调用 get_matches()函数来解析参数并获得 ArgMathces，然后对它进行模式匹配解析出相应指令，最后编写其对应的功能代码完成程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 use clap::{Command, arg, Arg}; fn main() { let cmd = Command::new(\u0026#34;CLI Name\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .author(\u0026#34;Name \u0026lt;email@email.com\u0026gt;\u0026#34;) .about(\u0026#34;Introduction\u0026#34;) .subcommand_required(true) // 位置参数 .arg( Arg::new(\u0026#34;input\u0026#34;) .help(\u0026#34;文件路径\u0026#34;) .required(true) ) // 选项参数 .arg( Arg::new(\u0026#34;name\u0026#34;) .short(\u0026#39;n\u0026#39;) .long(\u0026#34;name\u0026#34;) .help(\u0026#34;指定用户名\u0026#34;) .arg_required_else_help(true) ) // 定义子命令 .subcommand( Command::new(\u0026#34;diff\u0026#34;) .about(\u0026#34;比较两个文件\u0026#34;) .arg( Arg::new(\u0026#34;full\u0026#34;) .help(\u0026#34;全文比较\u0026#34;) .long(\u0026#34;full\u0026#34;) ) .arg( Arg::new(\u0026#34;info\u0026#34;) .help(\u0026#34;比较文件信息\u0026#34;) .long(\u0026#34;info\u0026#34;) ) ) ); let matches = cmd.get_matches(); // 匹配参数 let input = matches.value_of(\u0026#34;input\u0026#34;).unwrap(); println!(\u0026#34;输入文件: {}\u0026#34;, input); if let Some(name) = matches.value_of(\u0026#34;name\u0026#34;) { println!(\u0026#34;用户名: {}\u0026#34;, name); } else { println!(\u0026#34;未指定用户名\u0026#34;); } // 匹配子命令 match matches.subcommand { Some((\u0026#34;diff\u0026#34;, diff_matches)) =\u0026gt; { let full = diff_matches.get_one::\u0026lt;String\u0026gt;(\u0026#34;full\u0026#34;).map(|s| s.as_str()); TODO(\u0026#34;还是看官方Example好一些\u0026#34;); } } } Derive API Derive API 下，我们需要创建一个结构体表示命令行程序，随后可以向其中嵌套添加结构体或枚举表示子命令、参数等：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 use clap::Parser; #[derive(Parser)] #[command(next_line_help = true)] #[command(name = \u0026#34;hello\u0026#34;, version = \u0026#34;1.0\u0026#34;, about = \u0026#34;一个简单的示例程序\u0026#34;)] struct Cli { // Option\u0026lt;T\u0026gt; 表示可选参数 name: Option\u0026lt;String\u0026gt;, // 表示包含子命令。子命令定义在Commands枚举中 #[command(subcommand)] command: Commands, } #[derive(Subcommand)] enum Commands { #[command(about = \u0026#34;A subcommand\u0026#34;)] A, #[command(about = \u0026#34;B subcommand with args\u0026#34;)] B(BArgs), } #[derive(Args)] struct BArgs { // 定义参数，value_enum 表示该参数的值是可选的几个给定值 #[arg(short, long, required = true, value_enum)] #[arg(help = \u0026#34;Info mode\u0026#34;)] mode: BArgsMode, } #[derive(Copy, Clone, ValueEnum)] enum InfoFaArgsMode { #[value(help = \u0026#34;aa\u0026#34;)] AA, #[value(help = \u0026#34;aa\u0026#34;)] BB, } fn main() { let args = Cli::parse(); // 匹配可选参数 let name = args.name.unwrap(); //匹配定义的command 子命令 match args.command { Commands::A =\u0026gt; { TODO() }, Commands::B(args) =\u0026gt; { TODO() }, }\t} 常用配置 参数和子命令的一些设置 位置参数 结构体中不加 #[arg(short, long)] 时默认作为位置参数。位置参数可以直接使用： 1 my-app my_arg 选项参数 使用 #[arg(short, long)] 时作为选项参数，用户可以通过短选项（如 -n）或长选项（如 --name）传递参数： 1 my-app -a arg --barg arg 标志参数 当值的类型为布尔值时如 debug: bool 为标志参数，出现即为true,未出现为false。一般出现时与action联用（ #[arg(short, long, action = clap::ArgAction::Count)]）： 1 my-app --debug 对Command的配置 name version author about / long_about propagate_version 如果设置为 true，子命令也会显示顶级命令的版本信息。 #[command(propagate_version = true)] disable_help_flag / disable_version_flag 禁用时不会自动生成 --help 和 --version。 next_line_help 设为true时，帮助信息将会显示在命令名称的下一行。 term_width 指定帮助信息的输出宽度，便于美化输出。 #[command(term_width = 80)] allow_external_subcommands help_template 自定义帮助信息模板，如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #[derive(Parser)] #[command( about = \u0026#34;帮助信息定制示例\u0026#34;, help_template = \u0026#34;\\ {name} {version} {about} USAGE: {usage} {all-args} \u0026#34;, term_width = 80 )] 对subcommand的配置与此类似。\n对Args的配置 short 和 long 设置参数的短选项和长选项。 示例：#[arg(short, long)]（自动推导名称），也可以显式设置：#[arg(short = 'n', long = \u0026quot;name\u0026quot;)] help value_name 指定参数在帮助信息中显示的值名。 示例：#[arg(value_name = \u0026quot;FILE\u0026quot;)] default_value / default_value_t 设置默认值，可以是字符串或类型 T 的默认值。 示例：#[arg(default_value = \u0026quot;8080\u0026quot;)] 或 #[arg(default_value_t = 8080)] required / required_if / required_if_eq 控制参数是否必填，或在某些条件下必填。 示例：#[arg(required = true)] 或 #[arg(required_if_eq(\u0026quot;mode\u0026quot;, \u0026quot;a\u0026quot;))] env 没有输入参数时将从设定的环境变量中读取值作为该参数。 #[arg(env = \u0026quot;MYAPP_CONFIG\u0026quot;)] value_parser 设置参数的解析器，可以指定类型转换、范围限制或自定义验证函数。 示例：#[arg(value_parser = clap::value_parser!(u16).range(1..=65535))] action 针对布尔值或计数参数，可以指定行为，例如 Count（出现一次该参数则值增长1）或 SetTrue（只要参数出现出现就设为 true）。 #[arg(short, long, action = clap::ArgAction::Count)] conflicts_with / requires 用于定义参数之间的互斥或依赖关系。 示例：#[arg(conflicts_with = \u0026quot;other_arg\u0026quot;)] 或 #[arg(requires = \u0026quot;config\u0026quot;)] group 为参数设置组，同一个组的参数有一个被输入即可。 #[arg(group = \u0026quot;input\u0026quot;)] alias / short_alias / long_alias ","date":"2025-02-12T20:40:22+08:00","permalink":"https://hizhixia.site/post/clap%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/","title":"Clap的一些用法"},{"content":"Git真的是非常重要了！！但我编码不多，用到Git的场景也很少，一段时间不用就会忘掉好多命令和用法QwQ。\n按照一般的工作流记录一遍使用Git的工作流（顺便水一篇blog），顺便当个备忘录或教程（？），不要再忘了！\n配置Git 安装Git后，首先需要设置是谁在这台设备上使用Git工作，给自己注册个身份证：\n1 2 3 4 5 git config --global user.name \u0026#34;Name\u0026#34; git config --global user.email \u0026#34;Email@email.com\u0026#34; # --global 选项为用户级配置，在当前用户目录下(~)生成 .gitconfig # --system --local 分别为机器级配置和仓库级配置 # 分别生成在\tgithome 和 repo 下 为了方便使用Github或其他Git服务器，我们需要配置SSH。为防止冒名顶替可以配置GPG：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 若不支持 ed25519 则使用如下命令 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; gpg --full-generate-key # 若版本过旧使用如下命令 gpg --default-new-key-algo rsa4096 --gen-key # 查看现有的GPG密钥 gpg --list-secret-keys --keyid-format=long # 在Git中设置自己的私钥ID git config --global user.signingkey SEC_key_id git config --global commit.gpgsign true # 导出公钥 gpg --armor --export SEC_key_id 一些方便的命令 ^w^ ：\n1 2 3 4 5 6 7 8 9 10 11 # 更改git打开的文本编辑器 git config -- system core.editor vim # 长命令简写 git config -- global alias.diy_name_here command_here # 一条输出好看commit log的简写命令 git config -- global alias.loog log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit # 手动编辑config文件 git config -- global --edit 本地操作 要管理我们的项目，首先得创建一个Git库：\n1 2 3 4 5 git init my_proj # or mkdir my_proj cd my_proj git init 从头开始开发，先编写一些项目的配置文件，然后提交，作为最初的版本：\n1 2 3 4 5 6 7 8 9 # 添加所有文件到Stage git add . # 将内容从Stage提交 # -m \u0026#34;message\u0026#34; 选项附带简短的提交消息 git commit # 将当前Stage的内容合并到最近一次的提交，同时修改提交的message git commit -m \u0026#34;message\u0026#34; --amend 之后可以新建一个分支，在该分支上继续开发任务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看当前仓库分支 git branch # 新建分支 git branch dev # 切换到新分支（两条效果相同） git switch dev git checkout dev # 可以用以下表示新建并切换到新分区 git switch -c dev git checkout -b dev # 修改分支名 git branch -M old_name new_name # 或修改当前分支 git branch -M new_name 现在看看在开发时怎么进行版本管理（）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # 查看commit记录 # --pretty=oneline 选项简化输出每行显示一条commit # --oneline 选项简写commit id # -- file_here 选项显该文件相关的commit # --graph 选项图形化显示分支信息 git log # 查看当前仓库的状态 git status # 查看所有操作日志 git reflog # 若有文件被修改，查看工作区和Stage的差异 git diff file_name_here # 查看工作区或Stage与当前HEAD指向版本的差异 git diff HEAD -- file git diff HEAD --cached # revert 用于撤销指定commit的更改，并为此次撤销创建commit应用到当前分支 git revert commit_id_here # reset 用于回退到之前的版本 # HEAD^n 表示上n次提交 # --hard 已提交状态（删除工作区修改） --soft 未提交状态 --mixed 已添加未提交状态（） git reset --hard HEAD^ git reset --hard commit_id_here # 撤销*Stage*中已add的文件，保留工作区中的修改（不改变工作区） git restore --staged file # 与上条效果相同 git reset HEAD file # 撤销*Stage*中已add的文件，并撤销工作区中的修改使其与HEAD（若Stage中存在，则是Stage）一致 git restore file # 与上条命令效果相同 git checkout -- file # 删除文件 rm file git add. # 与上条效果相同 git rm file # 用于选取一次commit合并到当前分支 git cherry-pick commit_id # tag 用于为特定commit添加标签，可用于发布版本 # 当前命令为HEAD指向的commit添加标签 git tag tag_here # 为指定commit添加标签 git tag tag_here commit_id_here # -a 指定标签名 -m 指定标签说明 git tag -a tag_here -m \u0026#34;message\u0026#34; commit_id_here # 撤销打上的标签 git tag -d tag_here # 查看所有标签 git tag # 查看特定标签信息 git show tag_here 在该分支上完成开发任务后，可以合并到master分支：\n1 2 3 4 5 6 7 8 9 10 11 12 git switch master # 合并分支 # 默认 Fast-forward模式 合并 git merge dev # 合并后可删除分支 git branch -d dev # 如果分支在合并时太乱，可以Rebase成一条线 git rebase # 显示图形化的分支信息 git log --graph 协作开发 在本地使用Git进行版本管理进行得差不多了，现在看看如何使用Git借助远程仓库与别人协助工作。\n首先看看怎么进行远程仓库的一些相关操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 查看当前仓库的远程仓库信息 git remote -v # 为本地仓库添加远程仓库 git remote add remote_name remote_repo_uri # 推送选定分支到远程仓库 # --tags 选项推送本地所有tag git push remote_name branch_name # 将远程仓库作为选定本地分支的上游，简化push git push -u remote_name branch_name # 从远程仓库拉取 会merge到工作区 git pull remote_name # 从远程仓库拉取 只拉取仓库，不改变工作区，需要手动merge git ferch remote_name # 删除当前仓库和远程仓库的绑定信息 git remote rm remote_name # 从已有的远程仓库开始开发 git clone remote_name 多分支下与远程仓库的操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 查看远程仓库的分支 # -a 选项查看本地和远程的所有分支 git branch -r # 创建分支 # 将本地分支推送到远程。远程若没有则会创建 # -u 选项将绑定upstream，简化push git push remote_name branch_name # 一次推送本地所有分支 git push --all remote_name # 在本地创建分支，并与已存在的远程仓库关联 git checkout -b branch_name remote_name/remote_branch # 删除远程分支 git push remote_name --delete branch_name # 删除本地分支 git branch -d branch_name Patch和Submodule Patch用于记录代码的更改及应用，可以使用它生成最近几次的commit记录的patch，也可以很方便地把patch的改动合并：\n1 2 3 4 5 6 7 8 9 10 11 # 生成patch # 通过最近的n次commit生成n个patch git format-patch -n # 应用patch，但不会生成新的commit git apply patch_name.patch # 应用patch，但会生成新的commit git am patch_name.patch # 可使用send-email发送patch git send-email --to=\u0026#34;email\u0026#34; patch_name.patch Submodule用于管理大型项目，尤其是一个项目是由多个子项目构成时。例如Rust开发中使用 workspace 与 submodule 配合进行项目管理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 添加submodule # 添加本地的git仓库 git submodule add ./submodule_name # 添加远程仓库 git submodule add url submodule_path # 克隆带有 submodule 的仓库 git clone --recurse-submodules repo_url # 或克隆仓库后再获取submodule git submodule update --init --recursive # 为子模块commit后，包含它作为submodule的仓库也需要提交commit # submodule的远程仓库更新后，拉取最新代码 git submodule update --remote # 若只需要更新某个子模块 cd module_name git pull cd .. git add . \u0026amp;\u0026amp; git commit -m \u0026#34;message\u0026#34; # 删除submodule git submodule deinit -f module_name git rm -f module_name rm -rf .git/modules/module_name git commit -m \u0026#34;message\u0026#34; ","date":"2025-02-08T20:25:00+08:00","permalink":"https://hizhixia.site/post/%E5%86%8D%E5%AD%A6%E4%B8%80%E9%81%8Dgit/","title":"再学一遍Git"},{"content":"青春对我来说是一种自由的感觉。从以前到现在，社会身份逐渐自由，思想灵魂逃离自由。\n阴着却明亮的天，微凉的轻轻荡漾的风，在几棵柳树或橡树所在的地方，或跑或跳。 以前这样的场景最能使我的情绪激荡，当时仅靠环境就可以对情绪施加各样的压力，产生各种奇妙的感觉。而现在少有这种感觉了，或许是我的情绪本身不再敏感，或许是有更大的压力使我来不及感受，或许二者都有。\n最近某天我在一处公园的草地上散步，一不小心摔在了地上。 我趴在草坪上懵逼，脑子空空的，可能是闻到了草或泥土的味道（也肯定没闻到一些脏脏的味道），我没有着急起来，而是翻了个身继续躺。 我似乎捕捉到了以前有的某些感觉。但它来得很短暂，周围人聊天话语中一些破碎的字词让我想到一些关于生活或生存的事情，让我从地上拾起来。\n我现在理应拥有使用我身体以及让它进行一切行为的自由，但我的思想却不再能支配它们的自由了。\n","date":"2025-02-08T02:18:14+08:00","image":"https://hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E8%87%AA%E7%94%B1/flower1_hu_6bccffe159e6af08.jpg","permalink":"https://hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E8%87%AA%E7%94%B1/","title":"许多日前的自由"},{"content":"坐在电脑前神游时无意翻到了以前不知何时写的一些文字。\n今日来看往日，全是发疯，不过闲时看着倒是有些意思。随便找些搬运过来，刚好填补下空空如也的Blog。 还有许多自己拍的觉得有些意思的图，拿来当封面，这样看起来不至于很单调 ( .\n晚安 我正处在一处狭小的空间中，并不算好的环境和生活中的一些压力让我有些压抑。 但这时是夜，声音是寂静，颜色是望不到头的黑，我的情绪便能很好地融入在夜里。 也有不似白日里太阳的光，没有活力，冷冷地静止或移动。\n夜使我的忧郁或激昂看起来像是冷静，即使我知道这只是另一种疲倦。 我时而疲倦地叹息，时而疲倦地瘫坐，直到我忘记疲倦。 我不能走完完整的疲倦的夜，我不愿看它变成另一种无味，于是用睡眠来跨过夜的尸体，同时也让我如它一样无味。\n我记住梦前的晚安的话语，当作我梦中的幸运符，我在自己入睡前寄托所愿。 夜如此激发人的本能，希望传承的遗产。尽管这样，它仍使我安慰，它能带来安全的，温柔的睡和梦。\n今天的我还是不够好啊，所以，晚安。 明天的另一个我会怎么样呢，所以，晚安。 今天的自己将随夜留在今天，所以将最后的温柔带给自己，晚安！\n","date":"2025-02-08T01:13:35+08:00","image":"https://hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E6%99%9A%E5%AE%89/navigation_hu_6e80257c9fb2094e.jpg","permalink":"https://hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E6%99%9A%E5%AE%89/","title":"许多日前的晚安"},{"content":"Hello World Welcome to my Blog !!!\nIt was built with Hugo and the theme \u0026ldquo;Stack\u0026rdquo;.\n","date":"2025-01-30T13:30:00+08:00","image":"https://hizhixia.site/post/hello-world/cover_hu_843e06473c5bb246.jpg","permalink":"https://hizhixia.site/post/hello-world/","title":"Hello Wrold"}]