[{"content":"忧伤的色彩如油画一般。\n草儿长满山丘 草儿长满山丘，\n深蓝下嫩绿的一片\n红或黄的鲜艳零碎，\n分离散落着，\n让情绪饱和得柔乱\n\u0026nbsp;\n山风抚荡裙摆，\n点多溶作一系青岚\n某些与某些坐着，\n蓝色的幽暗水滴，\n绽在清澈的池中为伴\n\u0026nbsp;\n散落的花瓣捡起，\n轻轻触摸，\n眼中映出的霜英破败\n能否似这野芳模样，\n倘我能拥抱它的忧伤，\n可我似野芳一样\n\u0026nbsp;\n微风从岩石处涌来\n从山丘到峡谷，森林或海洋\n经过光的瘀伤，\n淌过溶解的月亮，\n流浪\n","date":"2025-03-29T15:07:31+08:00","image":"https://hizhixia.site/post/%E8%8D%89%E5%84%BF%E9%95%BF%E6%BB%A1%E5%B1%B1%E4%B8%98/navigation_hu_192c3794f42ff5c6.jpg","permalink":"https://hizhixia.site/post/%E8%8D%89%E5%84%BF%E9%95%BF%E6%BB%A1%E5%B1%B1%E4%B8%98/","title":"草儿长满山丘"},{"content":"进制表示法 计数时为了方便表示大的数量，因此采用进制表示法计数。\n#n进制计数法\n$n$ 进制计数法 代表的意思有：\n数到第 $n$ 个数就进位（如：0, 1, 2, 3, 4, 5, 6, 7, 8, 9，9是第十个数，数下一个数时就会进一位，即10。） 一共只有 $n$ 个不同的符号（比如十进制只有0到9，共10个数字。二进制只有0和1，共2个数字。） 一个数位上的数字可以选取 $n$ 个值，例如某个十进制表示数的个位可能取0到9这十个种的任意一个，有10种可能。 因此，一个n进制表示数如果有1位，则有 $n$ 种可能。有2位，则有 $n \\times n = n^2$ 种可能，以此类推，如果有 $x$ 位，则有 $n \\times n \\times \u0026hellip;\u0026hellip; \\times n = n^x$ 种可能。 也即，$x$ 位的 $n$ 进制表示数一共可以表示 $n^x$ 个数。比如一个2位的10进制数，可以表示从0到99一共100 ($10^2=100$)个数，一个4位的2进制数，可以表示从0到 1111 共 16 ($2^4=16$)个数。 #多个数位的产生\n在计数时，满了n就进一位，意思是着这时一位能表示的数字已经表示完了（n进制的n个数字已经用完了），所以才会 多用一位 来表达。比如数某个东西的数量，使用十进制，先用一位数，数到9时，已经不能表示更多了，所以多加一位来表示，这时就会进位，变成一个2位数 10。这时继续计数，到19时，个位又不能表示更多了，于是继续进位，变成20。当数到99时，这时个位不能表示更多，发生进位，十位也不能表示更多，于是继续进位，此时就会有三位的数字了。\n#通用一些的表示\n可以看出来，一位数每一位表示1个数字，一共能表示10个数字，而两位数中的十位是个位表示完它能表示的十个数字之后进位产生的，因此一个两位数的十位表示10个数字。比如一个两位数63，它表示的实际数量是$6\\times{10}+3$。 这里的 “个位十位” 的称呼是十进制专属的，对于所有进制表示法，一般用 “第0位，第1位” 表示。同时，每一位数字的值用 $d_0, d_1, \u0026hellip;$表示。 例如，十进制数字 $234$ 的第0位数字 $d_0=4$，第一位数字 $d_1=3$，第二位数字 $d_2=2$ 。\n以此类推，n进制表示法中，第0位数字表示的实际数量是 $d_0$，第1位数字表示的实际数量是 $d_1 \\times{n}$ ，第2位数字表示的实际数量是 $d_2\\times{n}\\times{n}$ 。\n#通用表示（按权展开）\n现在得到通用的表示，在 $n$ 进制表示法中，用 $D$ 表示一个数字表示的实际数量，则对于任意一个 $m$ 位的数字来说，都有: $$ D = d_m\\times{n^m} + d_{m-1}\\times{n^{m-1}} + \\dots + d_2\\times{n^{2}} + d_1\\times{n^{1} + d_0\\times{n^0}} $$\n因为我们是使用十进制进行计数的，我们使用的加法和乘法以及乘方都是十进制的，包括上面这个通用表示在描述时也是使用十进制表示实际数量的。\n#转换为十进制 所以对于任何一个n进制数，带入该通用表示 即可得到它表示的 十进制数的实际数量。\n#转换为任意进制 如果我们在这个通用表示中使用的是n进制，那我们只要使用n进制的数字表示，加法，乘法和乘方，那么我们只要带入该通用表示，就可以得到任何表示法表示的n进制数的实际数量。\n进制转换 转换为十进制 因为我们使用的就是十进制，所以先学习通用表示法转换为十进制：\n#二进制转换为十进制\n二进制100111 转十进制39： $$ D= 1 \\times 2^5 + 0 \\times 2^4 + 0 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 32 + 0 + 0 + 4 + 2 + 1 = 39_{10} $$ ​ #八进制转换为十进制\n八进制124 转十进制84： $$ D = 1 \\times 8^2 + 2 \\times 8^1 + 4 \\times 8^0 = 64 + 16 + 4 = 84_{10} $$\n#十六进制转换为十进制\n十六进制3E8₁₆ 转十进制1000： $$ D = 3 \\times 16^2 + 14 \\times 16^1 + 8 \\times 16^0 = 768 + 224 + 8 = 1000_{10}​ $$\n转换为n进制 这里首先介绍使用的是 通用表示法，假设我们要将 n 进制数转换 m 进制数，为使用通用表示法，首先要求 我们能把n进制表示法的n个数字以及这个n，用m进制表示（比如十进制转换为二进制时，需要知道0到10的二进制表示）。\n不要问为什么十进制表示法没这个要求，因为我们已经能把二进制，八进制，十六进制以及许多其他进制用十进制数字表示了 0v0 。回头看看上方通用表示法下面的 #转换为任意进制 的说明。\nTips: n进制的乘法可以使用竖式计算（各位相乘，各行累加，进位）\n以下为一个通用表示法的示例，由于要转换为m进制，就要学习n进制的乘法对于人来说比较麻烦，因此只做演示。 但对于常用的 二进制和十进制的转换 来说，已经足够了。\n#十进制转换为二进制\n#通用表示法（按权展开）\n十进制数39转换为二进制100111（0到10的二进制表示在文尾）： $$ D = 11 \\times 1010^{1} + 1001 \\times 1010^{0} = 11110 + 1001 = 100111_2 $$\n另一种十进制转换为二进制的方法是 除以2取余法，即十进制数除以2，然后取其余数（只可能是1或0）作为低位，逐步相除排列直到商为0时停止。\n#除以2取余法\n还是十进制数39： $$ 39 \\div 2 = 19 \\dots 1 $$ $$ 19 \\div 2 = 9 \\dots 1 $$ $$ 9 \\div 2 = 4 \\dots 1 $$ $$ 4 \\div 2 = 2 \\dots 0 $$ $$ 2 \\div 2 = 1 \\dots 0 $$ $$ 1 \\div 2 = 0 \\dots 1 $$\n排列余数，得100111 。\n二、八、十六进制的转换 很显然 8 和 16 分别是 $2^3, 2^4$，结合前面所说的，可以知道八进制的一位可以表示的实际数量需要二进制的三位来表示，十六进制的一位则需要用二进制的四位来表示。因此它们可以很方便地与二进制互相转换。\n这种方便在于，碰到比较长的数字时，转换起来比十进制的转换更快更 解压 。\n#二进制与十六进制\n因为1位十六进制需要用4位二进制表示，当你大概记得一些十六进制数字的二进制表示时，你会很快地得到转换结果。 比如：\n二进制10 1001 0111 1010 1011转换为十六进制：冒号后面没啥步骤了，直接按顺序写出来是 297AB 。\n十六进制3F8A转换为二进制：11 1111 1000 1010 。\n八进制也是同理。\n二进制与十六进制转换表 二进制 (4-bit) 十六进制 (Hex) 十进制 (Dec) 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 8 1001 9 9 1010 A 10 1011 B 11 1100 C 12 1101 D 13 1110 E 14 1111 F 15 ","date":"2025-02-20T00:40:47+08:00","permalink":"https://hizhixia.site/post/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","title":"进制转换"},{"content":"Rust的 Clap Crate 非常适用于开发命令行程序，它是一个“简单易用、高效且功能齐全的命令行参数解析器”。\nClap的作用在于帮助我们定义命令行工具的各种指令和用法，并解析用户使用的什么指令。之后我们只需要编写对应指令的功能代码即可。\n在这里简单记录一下它的一些用法。\ncrates.io: link docs.rs: link repo: link Exapmles: link 本文编写时：\n1 clap = \u0026#34;4.5.29\u0026#34; Clap的两种API Clap目前可以使用这两种方式构建命令行程序：\nBuilder API Derive API 官方的example多数都提供了两种方式的示例。 若要使用Derive API，记得要添加feature：\n1 clap = { version = \u0026#34;4.5.28\u0026#34;, features = [\u0026#34;derive\u0026#34;] } 两种构建方式的区别主要是：\nBuilder API\n链式调用的方式构建程序。 由于是 链式调用，代码 很长很复杂，可复用度较低。但在命令行参数需要经常变动调整时比较方便，加减几个函数调用就行。 Derive API\n声明式，通过定义命令和参数对应的 Strut 和 Enum 并在上面使用 属性宏 构建程序。 使用 声明式 构建，代码 直观简洁，方便理解和维护。适合参数和命令比较稳定的命令行程序。 使用 Derive API 可以兼顾开发效率和可维护性，同时上手方便。如果有复杂定制或控制更多细节的需求，再使用Builder API。 在特定情况下，Derive 和 Builder API 可以混合使用： Mixing Builder and Derive APIs\n使用方式 官方给的Git示例比较好，推荐查看：\ngit-Builder API git-Derive API Builder API Builder API 下，我们需要创建一个Command，通过调用 get_matches()函数来解析参数并获得 ArgMathces，然后对它进行模式匹配解析出相应指令，最后编写其对应的功能代码完成程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 use clap::{Command, arg, Arg}; fn main() { let cmd = Command::new(\u0026#34;CLI Name\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .author(\u0026#34;Name \u0026lt;email@email.com\u0026gt;\u0026#34;) .about(\u0026#34;Introduction\u0026#34;) .subcommand_required(true) // 位置参数 .arg( Arg::new(\u0026#34;input\u0026#34;) .help(\u0026#34;文件路径\u0026#34;) .required(true) ) // 选项参数 .arg( Arg::new(\u0026#34;name\u0026#34;) .short(\u0026#39;n\u0026#39;) .long(\u0026#34;name\u0026#34;) .help(\u0026#34;指定用户名\u0026#34;) .arg_required_else_help(true) ) // 定义子命令 .subcommand( Command::new(\u0026#34;diff\u0026#34;) .about(\u0026#34;比较两个文件\u0026#34;) .arg( Arg::new(\u0026#34;full\u0026#34;) .help(\u0026#34;全文比较\u0026#34;) .long(\u0026#34;full\u0026#34;) ) .arg( Arg::new(\u0026#34;info\u0026#34;) .help(\u0026#34;比较文件信息\u0026#34;) .long(\u0026#34;info\u0026#34;) ) ) ); let matches = cmd.get_matches(); // 匹配参数 let input = matches.value_of(\u0026#34;input\u0026#34;).unwrap(); println!(\u0026#34;输入文件: {}\u0026#34;, input); if let Some(name) = matches.value_of(\u0026#34;name\u0026#34;) { println!(\u0026#34;用户名: {}\u0026#34;, name); } else { println!(\u0026#34;未指定用户名\u0026#34;); } // 匹配子命令 match matches.subcommand { Some((\u0026#34;diff\u0026#34;, diff_matches)) =\u0026gt; { let full = diff_matches.get_one::\u0026lt;String\u0026gt;(\u0026#34;full\u0026#34;).map(|s| s.as_str()); TODO(\u0026#34;还是看官方Example好一些\u0026#34;); } } } Derive API Derive API 下，我们需要创建一个结构体表示命令行程序，随后可以向其中嵌套添加结构体或枚举表示子命令、参数等：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 use clap::Parser; #[derive(Parser)] #[command(next_line_help = true)] #[command(name = \u0026#34;hello\u0026#34;, version = \u0026#34;1.0\u0026#34;, about = \u0026#34;一个简单的示例程序\u0026#34;)] struct Cli { // Option\u0026lt;T\u0026gt; 表示可选参数 name: Option\u0026lt;String\u0026gt;, // 表示包含子命令。子命令定义在Commands枚举中 #[command(subcommand)] command: Commands, } #[derive(Subcommand)] enum Commands { #[command(about = \u0026#34;A subcommand\u0026#34;)] A, #[command(about = \u0026#34;B subcommand with args\u0026#34;)] B(BArgs), } #[derive(Args)] struct BArgs { // 定义参数，value_enum 表示该参数的值是可选的几个给定值 #[arg(short, long, required = true, value_enum)] #[arg(help = \u0026#34;Info mode\u0026#34;)] mode: BArgsMode, } #[derive(Copy, Clone, ValueEnum)] enum InfoFaArgsMode { #[value(help = \u0026#34;aa\u0026#34;)] AA, #[value(help = \u0026#34;aa\u0026#34;)] BB, } fn main() { let args = Cli::parse(); // 匹配可选参数 let name = args.name.unwrap(); //匹配定义的command 子命令 match args.command { Commands::A =\u0026gt; { TODO() }, Commands::B(args) =\u0026gt; { TODO() }, }\t} 常用配置 参数和子命令的一些设置 位置参数 结构体中不加 #[arg(short, long)] 时默认作为位置参数。位置参数可以直接使用： 1 my-app my_arg 选项参数 使用 #[arg(short, long)] 时作为选项参数，用户可以通过短选项（如 -n）或长选项（如 --name）传递参数： 1 my-app -a arg --barg arg 标志参数 当值的类型为布尔值时如 debug: bool 为标志参数，出现即为true,未出现为false。一般出现时与action联用（ #[arg(short, long, action = clap::ArgAction::Count)]）： 1 my-app --debug 对Command的配置 name version author about / long_about propagate_version 如果设置为 true，子命令也会显示顶级命令的版本信息。 #[command(propagate_version = true)] disable_help_flag / disable_version_flag 禁用时不会自动生成 --help 和 --version。 next_line_help 设为true时，帮助信息将会显示在命令名称的下一行。 term_width 指定帮助信息的输出宽度，便于美化输出。 #[command(term_width = 80)] allow_external_subcommands help_template 自定义帮助信息模板，如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #[derive(Parser)] #[command( about = \u0026#34;帮助信息定制示例\u0026#34;, help_template = \u0026#34;\\ {name} {version} {about} USAGE: {usage} {all-args} \u0026#34;, term_width = 80 )] 对subcommand的配置与此类似。\n对Args的配置 short 和 long 设置参数的短选项和长选项。 示例：#[arg(short, long)]（自动推导名称），也可以显式设置：#[arg(short = 'n', long = \u0026quot;name\u0026quot;)] help value_name 指定参数在帮助信息中显示的值名。 示例：#[arg(value_name = \u0026quot;FILE\u0026quot;)] default_value / default_value_t 设置默认值，可以是字符串或类型 T 的默认值。 示例：#[arg(default_value = \u0026quot;8080\u0026quot;)] 或 #[arg(default_value_t = 8080)] required / required_if / required_if_eq 控制参数是否必填，或在某些条件下必填。 示例：#[arg(required = true)] 或 #[arg(required_if_eq(\u0026quot;mode\u0026quot;, \u0026quot;a\u0026quot;))] env 没有输入参数时将从设定的环境变量中读取值作为该参数。 #[arg(env = \u0026quot;MYAPP_CONFIG\u0026quot;)] value_parser 设置参数的解析器，可以指定类型转换、范围限制或自定义验证函数。 示例：#[arg(value_parser = clap::value_parser!(u16).range(1..=65535))] action 针对布尔值或计数参数，可以指定行为，例如 Count（出现一次该参数则值增长1）或 SetTrue（只要参数出现出现就设为 true）。 #[arg(short, long, action = clap::ArgAction::Count)] conflicts_with / requires 用于定义参数之间的互斥或依赖关系。 示例：#[arg(conflicts_with = \u0026quot;other_arg\u0026quot;)] 或 #[arg(requires = \u0026quot;config\u0026quot;)] group 为参数设置组，同一个组的参数有一个被输入即可。 #[arg(group = \u0026quot;input\u0026quot;)] alias / short_alias / long_alias ","date":"2025-02-12T20:40:22+08:00","permalink":"https://hizhixia.site/post/clap%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/","title":"Clap的一些用法"},{"content":"Git真的是非常重要了！！但我编码不多，用到Git的场景也很少，一段时间不用就会忘掉好多命令和用法QwQ。\n按照一般的工作流记录一遍使用Git的工作流（顺便水一篇blog），顺便当个备忘录或教程（？），不要再忘了！\n配置Git 安装Git后，首先需要设置是谁在这台设备上使用Git工作，给自己注册个身份证：\n1 2 3 4 5 git config --global user.name \u0026#34;Name\u0026#34; git config --global user.email \u0026#34;Email@email.com\u0026#34; # --global 选项为用户级配置，在当前用户目录下(~)生成 .gitconfig # --system --local 分别为机器级配置和仓库级配置 # 分别生成在\tgithome 和 repo 下 为了方便使用Github或其他Git服务器，我们需要配置SSH。为防止冒名顶替可以配置GPG：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 若不支持 ed25519 则使用如下命令 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; gpg --full-generate-key # 若版本过旧使用如下命令 gpg --default-new-key-algo rsa4096 --gen-key # 查看现有的GPG密钥 gpg --list-secret-keys --keyid-format=long # 在Git中设置自己的私钥ID git config --global user.signingkey SEC_key_id git config --global commit.gpgsign true # 导出公钥 gpg --armor --export SEC_key_id 一些方便的命令 ^w^ ：\n1 2 3 4 5 6 7 8 9 10 11 # 更改git打开的文本编辑器 git config -- system core.editor vim # 长命令简写 git config -- global alias.diy_name_here command_here # 一条输出好看commit log的简写命令 git config -- global alias.loog log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit # 手动编辑config文件 git config -- global --edit 本地操作 要管理我们的项目，首先得创建一个Git库：\n1 2 3 4 5 git init my_proj # or mkdir my_proj cd my_proj git init 从头开始开发，先编写一些项目的配置文件，然后提交，作为最初的版本：\n1 2 3 4 5 6 7 8 9 # 添加所有文件到Stage git add . # 将内容从Stage提交 # -m \u0026#34;message\u0026#34; 选项附带简短的提交消息 git commit # 将当前Stage的内容合并到最近一次的提交，同时修改提交的message git commit -m \u0026#34;message\u0026#34; --amend 之后可以新建一个分支，在该分支上继续开发任务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看当前仓库分支 git branch # 新建分支 git branch dev # 切换到新分支（两条效果相同） git switch dev git checkout dev # 可以用以下表示新建并切换到新分区 git switch -c dev git checkout -b dev # 修改分支名 git branch -M old_name new_name # 或修改当前分支 git branch -M new_name 现在看看在开发时怎么进行版本管理（）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # 查看commit记录 # --pretty=oneline 选项简化输出每行显示一条commit # --oneline 选项简写commit id # -- file_here 选项显该文件相关的commit # --graph 选项图形化显示分支信息 git log # 查看当前仓库的状态 git status # 查看所有操作日志 git reflog # 若有文件被修改，查看工作区和Stage的差异 git diff file_name_here # 查看工作区或Stage与当前HEAD指向版本的差异 git diff HEAD -- file git diff HEAD --cached # revert 用于撤销指定commit的更改，并为此次撤销创建commit应用到当前分支 git revert commit_id_here # reset 用于回退到之前的版本 # HEAD^n 表示上n次提交 # --hard 已提交状态（删除工作区修改） --soft 未提交状态 --mixed 已添加未提交状态（） git reset --hard HEAD^ git reset --hard commit_id_here # 撤销*Stage*中已add的文件，保留工作区中的修改（不改变工作区） git restore --staged file # 与上条效果相同 git reset HEAD file # 撤销*Stage*中已add的文件，并撤销工作区中的修改使其与HEAD（若Stage中存在，则是Stage）一致 git restore file # 与上条命令效果相同 git checkout -- file # 删除文件 rm file git add. # 与上条效果相同 git rm file # 用于选取一次commit合并到当前分支 git cherry-pick commit_id # tag 用于为特定commit添加标签，可用于发布版本 # 当前命令为HEAD指向的commit添加标签 git tag tag_here # 为指定commit添加标签 git tag tag_here commit_id_here # -a 指定标签名 -m 指定标签说明 git tag -a tag_here -m \u0026#34;message\u0026#34; commit_id_here # 撤销打上的标签 git tag -d tag_here # 查看所有标签 git tag # 查看特定标签信息 git show tag_here 在该分支上完成开发任务后，可以合并到master分支：\n1 2 3 4 5 6 7 8 9 10 11 12 git switch master # 合并分支 # 默认 Fast-forward模式 合并 git merge dev # 合并后可删除分支 git branch -d dev # 如果分支在合并时太乱，可以Rebase成一条线 git rebase # 显示图形化的分支信息 git log --graph 协作开发 在本地使用Git进行版本管理进行得差不多了，现在看看如何使用Git借助远程仓库与别人协助工作。\n首先看看怎么进行远程仓库的一些相关操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 查看当前仓库的远程仓库信息 git remote -v # 为本地仓库添加远程仓库 git remote add remote_name remote_repo_uri # 推送选定分支到远程仓库 # --tags 选项推送本地所有tag git push remote_name branch_name # 将远程仓库作为选定本地分支的上游，简化push git push -u remote_name branch_name # 从远程仓库拉取 会merge到工作区 git pull remote_name # 从远程仓库拉取 只拉取仓库，不改变工作区，需要手动merge git ferch remote_name # 删除当前仓库和远程仓库的绑定信息 git remote rm remote_name # 从已有的远程仓库开始开发 git clone remote_name 多分支下与远程仓库的操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 查看远程仓库的分支 # -a 选项查看本地和远程的所有分支 git branch -r # 创建分支 # 将本地分支推送到远程。远程若没有则会创建 # -u 选项将绑定upstream，简化push git push remote_name branch_name # 一次推送本地所有分支 git push --all remote_name # 在本地创建分支，并与已存在的远程仓库关联 git checkout -b branch_name remote_name/remote_branch # 删除远程分支 git push remote_name --delete branch_name # 删除本地分支 git branch -d branch_name Patch和Submodule Patch用于记录代码的更改及应用，可以使用它生成最近几次的commit记录的patch，也可以很方便地把patch的改动合并：\n1 2 3 4 5 6 7 8 9 10 11 # 生成patch # 通过最近的n次commit生成n个patch git format-patch -n # 应用patch，但不会生成新的commit git apply patch_name.patch # 应用patch，但会生成新的commit git am patch_name.patch # 可使用send-email发送patch git send-email --to=\u0026#34;email\u0026#34; patch_name.patch Submodule用于管理大型项目，尤其是一个项目是由多个子项目构成时。例如Rust开发中使用 workspace 与 submodule 配合进行项目管理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 添加submodule # 添加本地的git仓库 git submodule add ./submodule_name # 添加远程仓库 git submodule add url submodule_path # 克隆带有 submodule 的仓库 git clone --recurse-submodules repo_url # 或克隆仓库后再获取submodule git submodule update --init --recursive # 为子模块commit后，包含它作为submodule的仓库也需要提交commit # submodule的远程仓库更新后，拉取最新代码 git submodule update --remote # 若只需要更新某个子模块 cd module_name git pull cd .. git add . \u0026amp;\u0026amp; git commit -m \u0026#34;message\u0026#34; # 删除submodule git submodule deinit -f module_name git rm -f module_name rm -rf .git/modules/module_name git commit -m \u0026#34;message\u0026#34; ","date":"2025-02-08T20:25:00+08:00","image":"https://hizhixia.site/post/%E5%86%8D%E5%AD%A6%E4%B8%80%E9%81%8Dgit/navigation_hu_6954e3234d2e2710.png","permalink":"https://hizhixia.site/post/%E5%86%8D%E5%AD%A6%E4%B8%80%E9%81%8Dgit/","title":"再学一遍Git"},{"content":"青春对我来说是一种自由的感觉。从以前到现在，社会身份逐渐自由，思想灵魂逃离自由。\n阴着却明亮的天，微凉的轻轻荡漾的风，在几棵柳树或橡树所在的地方，或跑或跳。 以前这样的场景最能使我的情绪激荡，当时仅靠环境就可以对情绪施加各样的压力，产生各种奇妙的感觉。而现在少有这种感觉了，或许是我的情绪本身不再敏感，或许是有更大的压力使我来不及感受，或许二者都有。\n最近某天我在一处公园的草地上散步，一不小心摔在了地上。 我趴在草坪上懵逼，脑子空空的，可能是闻到了草或泥土的味道（也肯定没闻到一些脏脏的味道），我没有着急起来，而是翻了个身继续躺。 我似乎捕捉到了以前有的某些感觉。但它来得很短暂，周围人聊天话语中一些破碎的字词让我想到一些关于生活或生存的事情，让我从地上拾起来。\n我现在理应拥有使用我身体以及让它进行一切行为的自由，但我的思想却不再能支配它们的自由了。\n","date":"2025-02-08T02:18:14+08:00","image":"https://hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E8%87%AA%E7%94%B1/flower1_hu_6bccffe159e6af08.jpg","permalink":"https://hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E8%87%AA%E7%94%B1/","title":"许多日前的自由"},{"content":"坐在电脑前神游时无意翻到了以前不知何时写的一些文字。\n今日来看往日，全是发疯，不过闲时看着倒是有些意思。随便找些搬运过来，刚好填补下空空如也的Blog。 还有许多自己拍的觉得有些意思的图，拿来当封面，这样看起来不至于很单调 ( .\n晚安 我正处在一处狭小的空间中，并不算好的环境和生活中的一些压力让我有些压抑。 但这时是夜，声音是寂静，颜色是望不到头的黑，我的情绪便能很好地融入在夜里。 也有不似白日里太阳的光，没有活力，冷冷地静止或移动。\n夜使我的忧郁或激昂看起来像是冷静，即使我知道这只是另一种疲倦。 我时而疲倦地叹息，时而疲倦地瘫坐，直到我忘记疲倦。 我不能走完完整的疲倦的夜，我不愿看它变成另一种无味，于是用睡眠来跨过夜的尸体，同时也让我如它一样无味。\n我记住梦前的晚安的话语，当作我梦中的幸运符，我在自己入睡前寄托所愿。 夜如此激发人的本能，希望传承的遗产。尽管这样，它仍使我安慰，它能带来安全的，温柔的睡和梦。\n今天的我还是不够好啊，所以，晚安。 明天的另一个我会怎么样呢，所以，晚安。 今天的自己将随夜留在今天，所以将最后的温柔带给自己，晚安！\n","date":"2025-02-08T01:13:35+08:00","image":"https://hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E6%99%9A%E5%AE%89/navigation_hu_6e80257c9fb2094e.jpg","permalink":"https://hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E6%99%9A%E5%AE%89/","title":"许多日前的晚安"},{"content":"Hello World Welcome to my Blog !!!\nIt was built with Hugo and the theme \u0026ldquo;Stack\u0026rdquo;.\n","date":"2025-01-30T13:30:00+08:00","image":"https://hizhixia.site/post/hello-world/cover_hu_843e06473c5bb246.jpg","permalink":"https://hizhixia.site/post/hello-world/","title":"Hello Wrold"}]